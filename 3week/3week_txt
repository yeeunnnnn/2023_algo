10815

1. 상근이가 가지고 있는 숫자들과 주어진 숫자들 간의 일치 여부를 판단하는 문제임.
숫자들을 빠르게 찾기 위해 배열을 사용하여 숫자들을 표시하고, 주어진 숫자들에 대해 배열에 해당 숫자가 존재하는지 판단.
2. 배열 sang_gen_have를 생성하고 모든 원소를 0으로 초기화합니다. 이 배열은 상근이가 가지고 있는 숫자들을 표시하기 위한 배열로, -10000000부터 10000000까지의 범위를 가집니다. (10000000 * 2 + 1)
    
    숫자의 개수 N을 입력받습니다.
    
    N개의 숫자를 입력받아 배열 sang_gen_have에 해당하는 숫자의 인덱스를 1로 표시합니다. 입력받은 숫자에 -10000000을 더한 값이 배열 sang_gen_have의 인덱스가 됩니다.
    
    찾고자 하는 숫자의 개수 M을 입력받습니다.
    
    M개의 숫자를 입력받고, 각 숫자에 대해 배열 sang_gen_have에서 해당하는 숫자의 인덱스를 검사하여 값이 1이면 1을 출력하고, 아니면 0을 출력합니다.
    
    반복문이 종료되면 프로그램을 종료합니다.
    

10816

1. 이 문제는 N개의 숫자로 이루어진 배열 card가 주어지고, M개의 숫자를 입력받은 뒤, 배열 card에 각 숫자가 몇 개 있는지 구하는 문제입니다.
배열 card는 정렬된 상태로 주어지므로, 이진 탐색을 활용하여 각 숫자의 등장 횟수를 빠르게 찾을 수 있습니다.
2. N을 입력받아 배열 card에 N개의 숫자를 저장합니다.
    
    배열 card를 오름차순으로 정렬합니다. (여기서는 qsort 함수를 사용)
    
    M을 입력받아 M개의 숫자를 처리합니다.
    
    각 숫자 x에 대해 이진 탐색을 통해 card 배열에서 x가 처음으로 등장하는 인덱스를 찾는 lower_bound 함수와, x가 마지막으로 등장하는 인덱스보다 한 칸 더 뒤의 인덱스를 찾는 upper_bound 함수를 호출합니다.
    
    upper_bound - lower_bound 값을 출력합니다. 이 값은 x가 card 배열에서 등장하는 횟수를 의미합니다.
    
    모든 숫자에 대한 등장 횟수를 출력하고, 프로그램을 종료합니다.
    

11931

1. N개의 숫자로 이루어진 배열을 내림차순으로 정렬하는 문제입니다. 주어진 숫자들을 배열에 저장한 뒤, qsort 함수를 사용하여 배열을 내림차순으로 정렬하고 정렬된 결과를 출력하면 됩니다.
2. N을 입력받습니다.
    
    N개의 숫자를 저장할 수 있는 동적 배열(numbers)을 생성합니다. 배열의 크기는 N * sizeof(int)입니다.
    
    N개의 숫자를 입력받아 배열 numbers에 저장합니다.
    
    qsort 함수를 사용하여 배열 numbers를 내림차순으로 정렬합니다. compare_desc 함수를 비교 함수로 사용하여 정렬합니다.
    
    정렬된 배열 numbers를 출력합니다.
    
    동적으로 할당한 배열 numbers의 메모리를 해제합니다.
    
    프로그램을 종료합니다.
    

2003

1. N개의 숫자로 이루어진 배열 A가 주어지고, M보다 크거나 같은 연속된 부분 배열의 개수를 구하는 문제입니다. 이 문제는 투 포인터(Two Pointers) 알고리즘을 사용하여 해결할 수 있습니다.
2. N과 M을 입력받습니다.
    
    N개의 숫자를 저장할 수 있는 동적 배열(A)을 생성합니다. 배열의 크기는 (N + 1) * sizeof(LL)입니다.
    
    N개의 숫자를 입력받아 배열 A에 저장합니다.
    
    투 포인터 알고리즘을 사용하여 합과 M을 비교하면서 연속된 부분 배열의 개수를 구합니다.
    
    left와 right를 1로 초기화하고, sum을 0으로 초기화합니다.
    right를 이동시키면서 sum에 A[right] 값을 더합니다.
    sum이 M 이상이면 left를 오른쪽으로 이동하고, sum에서 A[left] 값을 빼줍니다.
    sum이 M과 같으면 answer를 증가시킵니다.
    right가 N + 1에 도달하거나 sum이 M보다 작아지면 반복을 종료합니다.
    answer를 출력합니다.
    
    동적으로 할당한 배열 A의 메모리를 해제합니다.
    
    프로그램을 종료합니다.
    

11659

1. 이 문제는 N개의 숫자로 이루어진 배열 num이 주어지고, M개의 쿼리가 주어질 때 각 쿼리에 대해 해당하는 구간의 합을 구하는 문제입니다.
입력으로 주어진 숫자들의 누적 합을 미리 계산하여 배열 sum에 저장한 뒤, 각 쿼리에 대해 sum 배열을 이용하여 구간 합을 빠르게 계산합니다.
2. N과 M을 입력받습니다.
    
    N개의 숫자를 저장할 수 있는 배열 num과 누적 합을 저장할 수 있는 배열 sum을 생성합니다. 배열의 크기는 각각 100001입니다.
    
    N개의 숫자를 입력받아 배열 num에 저장합니다. 동시에 누적 합을 계산하여 배열 sum에 저장합니다. sum[i]에는 num[1]부터 num[i]까지의 누적 합이 저장됩니다.
    
    M개의 쿼리를 처리합니다.
    
    각 쿼리에 대해 구간의 시작과 끝 인덱스인 i와 j를 입력받습니다.
    sum[j] - sum[i - 1]을 계산하여 구간 합을 구합니다.
    구간 합을 출력합니다.
    프로그램을 종료합니다.