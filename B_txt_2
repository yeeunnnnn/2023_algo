2747, 13699

1) 피보나치 수열 코드를 적는데 for 문을 사용하여 2부터 n까지 반복하도록 구성

2) 사용자 입력: scanf 함수를 사용하여 사용자로부터 정수 n을 입력받는다.
   이 n 값은 피보나치 수열에서 원하는 순서 위치이며, 0 또는 양의 정수일 것으로 가정.
   이 때, fibo2가 첫 번째 출력으로 사용됨.
   fibo = 0, fibo1 = 1, fibo2 = 1
   반복문 작성: for 문을 사용하여 2부터 n까지 반복하도록 구성합니다. 이 반복문 내에서 다음과 같은 작업을 수행합니다.
   a. 다음 피보나치 수를 계산합니다. 다음 피보나치 수는 fibo2에 저장되며, 이는 이전 두 피보나치 숫자의 합입니다 (fibo2 = fibo + fibo1).
   b. fibo 변수를 현재 피보나치 수(fibo1)로 업데이트합니다. (fibo = fibo1)
   c. fibo1 변수를 다음 피보나치 수(fibo2)로 업데이트합니다. (fibo1 = fibo2)
   결과 출력: 계산된 n번째 피보나치 수(fibo2)를 출력합니다.

11659

1) 'sum'이라는 배열을 선언하고, sum[0]=0, sum[k]=num[1]+num[2]+...+num[k]로 초기화 한다.
   구간 합을 구하기 위한 M개의 쿼리를 입력 받는다.
   i부터 j까지의 합을 구하기 위해 sum[j]-sum[i-1]을 출력한다

2) 1. 정수 N, M, i, j, num[100001], sum[100001]={0,}
    2. (for문) k=1부터 N까지, num[k]를 입력 받는다. 
	2.1. sum[k]=sum[k-1]+num[k]
    3. (for문) k=1부터 M까지, 
	3.1. 구간합을 구하기 위한 구간 [i,j]를 입력 받는다.
	3.2. printf("%d\n", sum[j]-sum[i-1])
4. 종료


16395

1) 파스칼의 삼각형에서 n번째 행, k번째 열의 값을 계산하는 함수를 재귀적으로 구현

2) 함수 pascal_square(n, k)를 선언한다.
   n, k값을 입력받는다.
   만약 n이 30보다 작거나 같고, k가 n보다 작거나 같으면 다음 단계를 진행한다.
   함수 pascal_square(n, k)를 호출하여 반환값을 sum에 저장한다.
   sum을 출력한다.
   프로그램을 종료한다.
   pascal_square(n, k) 함수를 선언한다.
   만약 n이 1이라면 1을 반환한다.
   만약 n이 k와 같다면 1을 반환한다.
   만약 k가 1이라면 1을 반환한다.
   k가 1보다 크고, n이 1보다 크다면, 함수 pascal_square(n - 1, k) + pascal_square(n - 1, k - 1)를 반환한다.

11047

1) 동전의 단위를 입력받아 배열에 저장합니다.
   가장 큰 단위부터 동전을 넣을 수 있는 만큼 사용하고, 사용한 동전의 개수를 카운트에 추가합니다.
   남은 금액이 존재할 경우, 남은 금액이 0이 될 때까지 2번 과정을 반복합니다.
   카운트에 추가된 동전 개수를 출력합니다.

2) 1. 동전의 단위를 입력받아 배열에 저장한다.
   2. 카운트 변수(cnt)를 0으로 초기화한다.
   3. 가장 큰 단위의 동전부터 사용할 수 있는 만큼 사용하고, 사용한 개수를 cnt에 추가한다.
   4. 남은 금액이 존재할 경우 3번 과정을 반복한다.
   5. cnt를 출력한다.